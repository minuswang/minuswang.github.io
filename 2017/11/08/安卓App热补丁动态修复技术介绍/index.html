<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="安卓App热补丁动态修复技术介绍"/>








  <link rel="alternate" href="/default" title="Minus Wang">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://minus.wang/2017/11/08/安卓App热补丁动态修复技术介绍/"/>


<meta name="description" content="QQ空间开发团队-安卓App热补丁动态修复技术介绍  1.背景  当一个App发布之后，突然发现了一个严重bug需要进行紧急修复，这时候公司各方就会忙得焦头烂额：重新打包App、测试、向各个应用市场和渠道换包、提示用户升级、用户下载、覆盖安装。有时候仅仅是为了修改了一行代码，也要付出巨大的成本进行换包和重新发布。这时候就提出一个问题：有没有办法以补丁的方式动态修复紧急Bug，不再需要重新发布Ap">
<meta property="og:type" content="article">
<meta property="og:title" content="安卓App热补丁动态修复技术介绍">
<meta property="og:url" content="http://minus.wang/2017/11/08/安卓App热补丁动态修复技术介绍/index.html">
<meta property="og:site_name" content="Minus Wang">
<meta property="og:description" content="QQ空间开发团队-安卓App热补丁动态修复技术介绍  1.背景  当一个App发布之后，突然发现了一个严重bug需要进行紧急修复，这时候公司各方就会忙得焦头烂额：重新打包App、测试、向各个应用市场和渠道换包、提示用户升级、用户下载、覆盖安装。有时候仅仅是为了修改了一行代码，也要付出巨大的成本进行换包和重新发布。这时候就提出一个问题：有没有办法以补丁的方式动态修复紧急Bug，不再需要重新发布Ap">
<meta property="og:image" content="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu75fv55IpLkDqm2MibiaVQNFMQ3xFNk9ez1CXPibFPn0ibiboQf2kWPfSL8Mg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7dVfrXN7XxhOjiaahHricl00hal4rjw1cQ2LRFKVGU7uUOO0Q5HSz7hKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7L1OTRicUdpKy3Txd5eancPZXSWKVic4S9A7rUticj9aKY5UhfbAhjpLjg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7tC9UtEopH3nCy3WxLufdwribQYGesIeofBebMwHwbAicvOH1FTzicVMdQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7OwicJpMnQicGxNCs2NWFTNuTjknjCoaCuvBMEUYrxvKJmMBVty3icB1Rw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7N1uaUdav2cvKA5H1KtVZOcQVN2uCkiaQOJVJH3yicice5q3VPtHLMB5OA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7VbBsSqeZLGliaLlDJrCIgia5xXFr1YNqiczJUMdG89yibBrPQQNUYiaKOLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7mGslV1vlR4dHWbmYZ0qrpBsicKIIHR2uia5mqDDBuGjLcQkrIcNuqC1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="http://img.blog.csdn.net/20160630102448728">
<meta property="og:image" content="http://img.blog.csdn.net/20160702112015730">
<meta property="og:image" content="http://img.blog.csdn.net/20160702113157906">
<meta property="og:image" content="http://img.blog.csdn.net/20160702113213904">
<meta property="og:image" content="http://img.blog.csdn.net/20160702113810924">
<meta property="og:image" content="http://img.blog.csdn.net/20160702114443271">
<meta property="og:image" content="http://img.blog.csdn.net/20160702121447650">
<meta property="og:image" content="http://img.blog.csdn.net/20160702125948475">
<meta property="og:image" content="http://img.blog.csdn.net/20160702130113648">
<meta property="og:image" content="http://img.blog.csdn.net/20160702132032598">
<meta property="og:image" content="http://img.blog.csdn.net/20160702132048858">
<meta property="og:image" content="https://camo.githubusercontent.com/d27da621a6d7e8f612a3fe458b59a68ecb927bce/687474703a2f2f376676696f762e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f6e7577612e6a7067">
<meta property="og:updated_time" content="2017-11-08T06:34:18.634Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安卓App热补丁动态修复技术介绍">
<meta name="twitter:description" content="QQ空间开发团队-安卓App热补丁动态修复技术介绍  1.背景  当一个App发布之后，突然发现了一个严重bug需要进行紧急修复，这时候公司各方就会忙得焦头烂额：重新打包App、测试、向各个应用市场和渠道换包、提示用户升级、用户下载、覆盖安装。有时候仅仅是为了修改了一行代码，也要付出巨大的成本进行换包和重新发布。这时候就提出一个问题：有没有办法以补丁的方式动态修复紧急Bug，不再需要重新发布Ap">
<meta name="twitter:image" content="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu75fv55IpLkDqm2MibiaVQNFMQ3xFNk9ez1CXPibFPn0ibiboQf2kWPfSL8Mg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> 安卓App热补丁动态修复技术介绍 - Minus Wang </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Minus Wang</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                Me
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/daohang">
                            
                            
                                Site
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/notes">
                            
                            
                                Note
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          安卓App热补丁动态修复技术介绍
        
      </h1>

      <time class="post-time">
          Nov 8 2017
      </time>
    </header>



    
            <div class="post-content">
            <p> <a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect" target="_blank" rel="external">QQ空间开发团队-安卓App热补丁动态修复技术介绍</a></p>
<blockquote>
<p>1.背景</p>
</blockquote>
<p>当一个App发布之后，突然发现了一个严重bug需要进行紧急修复，这时候公司各方就会忙得焦头烂额：重新打包App、测试、向各个应用市场和渠道换包、提示用户升级、用户下载、覆盖安装。有时候仅仅是为了修改了一行代码，也要付出巨大的成本进行换包和重新发布。<br>这时候就提出一个问题：有没有办法以补丁的方式动态修复紧急Bug，不再需要重新发布App，不再需要用户重新下载，覆盖安装？<br>虽然Android系统并没有提供这个技术，但是很幸运的告诉大家，答案是：可以，我们QQ空间提出了热补丁动态修复技术来解决以上这些问题。</p>
<blockquote>
<p>2.实际案例</p>
</blockquote>
<p>空间Android独立版5.2发布后，收到用户反馈，结合版无法跳转到独立版的访客界面，每天都较大的反馈。在以前只能紧急换包，重新发布。成本非常高，也影响用户的口碑。最终决定使用热补丁动态修复技术，向用户下发Patch，在用户无感知的情况下，修复了外网问题，取得非常好的效果。</p>
<blockquote>
<p>3.解决方案</p>
</blockquote>
<p>该方案基于的是<code>android dex</code>分包方案的，关于<code>dex</code>分包方案，网上有几篇解释了，所以这里就不再赘述，具体可以看这里<a href="https://m.oschina.net/blog/308583。" target="_blank" rel="external">https://m.oschina.net/blog/308583。</a><br>简单的概括一下，就是把多个<code>dex</code>文件塞入到<code>app</code>的<code>classloader</code>之中，但是<code>android dex</code>拆包方案中的类是没有重复的，如果<code>classes.dex</code>和<code>classes1.dex</code>中有重复的类，当用到这个重复的类的时候，系统会选择哪个类进行加载呢？<br>让我们来看看类加载的代码：<br><img src="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu75fv55IpLkDqm2MibiaVQNFMQ3xFNk9ez1CXPibFPn0ibiboQf2kWPfSL8Mg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""><br>一个<code>ClassLoader</code>可以包含多个<code>dex</code>文件，每个<code>dex</code>文件是一个<code>Element</code>，多个<code>dex</code>文件排列成一个有序的数组<code>dexElements</code>，当找类的时候，会按顺序遍历<code>dex</code>文件，然后从当前遍历的<code>dex</code>文件中找类，如果找类则返回，如果找不到从下一个<code>dex</code>文件继续查找。<br>理论上，如果在不同的<code>dex</code>中有相同的类存在，那么会优先选择排在前面的<code>dex</code>文件的类，如下图：<br><img src="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7dVfrXN7XxhOjiaahHricl00hal4rjw1cQ2LRFKVGU7uUOO0Q5HSz7hKw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""><br>在此基础上，我们构想了热补丁的方案，把有问题的类打包到一个<code>dex（patch.dex）</code>中去，然后把这个<code>dex</code>插入到<code>Elements</code>的最前面，如下图：<br><img src="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7L1OTRicUdpKy3Txd5eancPZXSWKVic4S9A7rUticj9aKY5UhfbAhjpLjg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""><br>好，该方案基于第二个拆分<code>dex</code>的方案，方案实现如果懂拆分<code>dex</code>的原理的话，大家应该很快就会实现该方案，如果没有拆分<code>dex</code>的项目的话，可以参考一下谷歌的<code>multidex</code>方案实现。然后在插入数组的时候，把补丁包插入到最前面去。<br>好，看似问题很简单，轻松的搞定了，让我们来试验一下，修改某个类，然后打包成<code>dex</code>，插入到<code>classloader</code>，当加载类的时候出现了（本例中是<code>QzoneActivityManager</code>要被替换）：<br><img src="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7tC9UtEopH3nCy3WxLufdwribQYGesIeofBebMwHwbAicvOH1FTzicVMdQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""><br>为什么会出现以上问题呢？<br>从<code>log</code>的意思上来讲，<code>ModuleManager</code>引用了<code>QzoneActivityManager</code>，但是发现这这两个类所在的<code>dex</code>不在一起，其中：</p>
<ol>
<li><code>ModuleManager</code>在<code>classes.dex</code>中</li>
<li><p><code>QzoneActivityManager</code>在<code>patch.dex</code>中<br>结果发生了错误。<br>这里有个问题,拆分<code>dex</code>的很多类都不是在同一个<code>dex</code>内的,怎么没有问题?<br>让我们搜索一下抛出错误的代码所在，嘿咻嘿咻，找到了一下代码：<br><img src="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7OwicJpMnQicGxNCs2NWFTNuTjknjCoaCuvBMEUYrxvKJmMBVty3icB1Rw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""><br>从代码上来看，如果两个相关联的类在不同的dex中就会报错，但是拆分dex没有报错这是为什么，原来这个校验的前提是：<br><img src="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7N1uaUdav2cvKA5H1KtVZOcQVN2uCkiaQOJVJH3yicice5q3VPtHLMB5OA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""><br>如果引用者（也就是<code>ModuleManager</code>）这个类被打上了<code>CLASS_ISPREVERIFIED</code>标志，那么就会进行<code>dex</code>的校验。那么这个标志是什么时候被打上去的？让我们在继续搜索一下代码，嘿咻嘿咻~~，在<code>DexPrepare.cpp</code>找到了一下代码：<br><img src="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7VbBsSqeZLGliaLlDJrCIgia5xXFr1YNqiczJUMdG89yibBrPQQNUYiaKOLQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""><br>这段代码是<code>dex</code>转化成<code>odex(dexopt)</code>的代码中的一段，我们知道当一个<code>apk</code>在安装的时候，<code>apk</code>中的<code>classes.dex</code>会被虚拟机<code>(dexopt)</code>优化成<code>odex</code>文件，然后才会拿去执行。<br>虚拟机在启动的时候，会有许多的启动参数，其中一项就是<code>verify</code>选项，当<code>verify</code>选项被打开的时候，上面doVerify变量为true，那么就会执行<code>dvmVerifyClass</code>进行类的校验，如果<code>dvmVerifyClass</code>校验类成功，那么这个类会被打上<code>CLASS_ISPREVERIFIED</code>的标志，那么具体的校验过程是什么样子的呢？<br>此代码在DexVerify.cpp中，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. 验证clazz-&gt;directMethods方法，directMethods包含了以下方法：</div><div class="line">1. static方法</div><div class="line">2. private方法</div><div class="line">3. 构造函数</div><div class="line">2. clazz-&gt;virtualMethods</div></pre></td></tr></table></figure>
</li>
<li><p>虚函数=override方法?<br>概括一下就是如果以上方法中直接引用到的类（第一层级关系，不会进行递归搜索）和clazz都在同一个dex中的话，那么这个类就会被打上CLASS_ISPREVERIFIED：</p>
</li>
</ol>
<blockquote>
<p>所以为了实现补丁方案，所以必须从这些方法中入手，防止类被打上CLASS_ISPREVERIFIED标志。</p>
<p>最终空间的方案是往所有类的构造函数里面插入了一段代码，代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ClassVerifier.PREVENT_VERIFY) &#123;</div><div class="line">System.out.println(AntilazyLoad.class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>AntilazyLoad</code>类会被打包成单独的<code>hack.dex</code>，这样当安装<code>apk</code>的时候，<code>classes.dex</code>内的类都会引用一个在不相同<code>dex</code>中的<code>AntilazyLoad</code>类，这样就防止了类被打上<code>CLASS_ISPREVERIFIED</code>的标志了，只要没被打上这个标志的类都可以进行打补丁操作。</p>
<p>然后在应用启动的时候加载进来<code>.AntilazyLoad</code>类所在的<code>dex</code>包必须被先加载进来,不然<code>AntilazyLoad</code>类会被标记为不存在，即使后续加载了<code>hack.dex</code>包，那么他也是不存在的，这样屏幕就会出现茫茫多的类<code>AntilazyLoad</code>找不到的<code>log</code>。</p>
<p>所以<code>Application</code>作为应用的入口不能插入这段代码。（因为载入<code>hack.dex</code>的代码是在<code>Application</code>中<code>onCreate</code>中执行的，如果在<code>Application</code>的构造函数里面插入了这段代码，那么就是在<code>hack.dex</code>加载之前就使用该类，该类一次找不到，会被永远的打上找不到的标志)<br>其中:<br><img src="http://mmbiz.qpic.cn/mmbiz/0aYRVN1mAJwR6vqR4Yv6V3zIvjqmgdu7mGslV1vlR4dHWbmYZ0qrpBsicKIIHR2uia5mqDDBuGjLcQkrIcNuqC1g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<blockquote>
<p>之所以选择构造函数是因为他不增加方法数，一个类即使没有显式的构造函数，也会有一个隐式的默认构造函数。</p>
<p>空间使用的是在字节码插入代码,而不是源代码插入，使用的是javaassist库来进行字节码插入的。</p>
<p>隐患:</p>
</blockquote>
<p>虚拟机在安装期间为类打上<code>CLASS_ISPREVERIFIED</code>标志是为了提高性能的，我们强制防止类被打上标志是否会影响性能？这里我们会做一下更加详细的性能测试．但是在大项目中拆分<code>dex</code>的问题已经比较严重，很多类都没有被打上这个标志。</p>
<blockquote>
<p>如何打包补丁包：</p>
</blockquote>
<ol>
<li><p>空间在正式版本发布的时候，会生成一份缓存文件，里面记录了所有class文件的md5，还有一份mapping混淆文件。</p>
</li>
<li><p>在后续的版本中使用-applymapping选项，应用正式版本的mapping文件，然后计算编译完成后的class文件的md5和正式版本进行比较，把不相同的class文件打包成补丁包。</p>
</li>
</ol>
<p>备注:该方案现在也应用到我们的编译过程当中,编译不需要重新打包dex,只需要把修改过的类的class文件打包成patch dex,然后放到sdcard下,那么就会让改变的代码生效。</p>
<h2 id="转载自-Android-热修复其实很简单"><a href="#转载自-Android-热修复其实很简单" class="headerlink" title="转载自 Android 热修复其实很简单"></a>转载自 <a href="http://blog.csdn.net/qq_31530015/article/details/51785228?locationNum=11" target="_blank" rel="external">Android 热修复其实很简单</a></h2><h3 id="一、什么是热修复"><a href="#一、什么是热修复" class="headerlink" title="一、什么是热修复"></a>一、什么是热修复</h3><p>热修复说白了就是”打补丁”，比如你们公司上线一个app，用户反应有重大bug,需要紧急修复。如果按照通常做法,那就是程序猿加班搞定bug,然后测试,重新打包并发布。这样带来的问题就是成本高,效率低。于是,热修复就应运而生.一般通过事先设定的接口从网上下载无Bug的代码来替换有Bug的代码。这样就省事多了,用户体验也好。</p>
<h3 id="二、热修复的原理"><a href="#二、热修复的原理" class="headerlink" title="二、热修复的原理"></a>二、热修复的原理</h3><ol>
<li>Android的类加载机制</li>
</ol>
<p>Android的类加载器分为两种,<code>PathClassLoader</code>和<code>DexClassLoader</code>，两者都继承自<code>BaseDexClassLoader</code></p>
<p><code>PathClassLoader</code>代码位于<code>libcore\dalvik\src\main\java\dalvik\system\PathClassLoader.java</code><br><code>DexClassLoader</code>代码位于<code>libcore\dalvik\src\main\java\dalvik\system\DexClassLoader.java</code><br><code>BaseDexClassLoader</code>代码位于<code>libcore\dalvik\src\main\java\dalvik\system\BaseDexClassLoader.java</code></p>
<blockquote>
<p><code>PathClassLoader</code>  用来加载系统类和应用类</p>
<p><code>DexClassLoader</code> 用来加载<code>jar、apk、dex</code>文件.加载<code>jar、apk</code>也是最终抽取里面的<code>Dex</code>文件进行加载.</p>
</blockquote>
<p>这里写图片描述<br><img src="http://img.blog.csdn.net/20160630102448728" alt=""></p>
<ol>
<li>热修复机制</li>
</ol>
<p>看下<code>PathClassLoader</code>代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath,</span></span></div><div class="line"><span class="function"><span class="params">            ClassLoader parent)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, libraryPath, parent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>DexClassLoader</code>代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>两个<code>ClassLoader</code>就两三行代码,只是调用了父类的构造函数.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></div><div class="line"><span class="function"><span class="params">            String libraryPath, ClassLoader parent)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(parent);</div><div class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</div><div class="line">        Class c = pathList.findClass(name, suppressedExceptions);</div><div class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</div><div class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</div><div class="line">                cnfe.addSuppressed(t);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> cnfe;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> c;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在BaseDexClassLoader 构造函数中创建一个DexPathList类的实例,这个DexPathList的构造函数会创建一个dexElements 数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory)</span> </span>&#123;</div><div class="line">        ... </div><div class="line">        <span class="keyword">this</span>.definingContext = definingContext;</div><div class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</div><div class="line">        <span class="comment">//创建一个数组</span></div><div class="line">        <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions);</div><div class="line">        ... </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>然后BaseDexClassLoader 重写了findClass方法,调用了pathList.findClass，跳到DexPathList类中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* package */</span><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</div><div class="line">            <span class="comment">//遍历该数组</span></div><div class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</div><div class="line">            <span class="comment">//初始化DexFile</span></div><div class="line">            DexFile dex = element.dexFile;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//调用DexFile类的loadClassBinaryName方法返回Class实例</span></div><div class="line">                Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</div><div class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> clazz;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;       </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>会遍历这个数组,然后初始化DexFile，如果DexFile不为空那么调用DexFile类的loadClassBinaryName方法返回Class实例. </p>
<blockquote>
<p>归纳上面的话就是:ClassLoader会遍历这个数组,然后加载这个数组中的dex文件. </p>
</blockquote>
<p>而ClassLoader在加载到正确的类之后,就不会再去加载有Bug的那个类了,我们把这个正确的类放在Dex文件中,让这个Dex文件排在dexElements数组前面即可.</p>
<p>这里有个问题,可参考QQ空间团队的 <a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect%20%20%20da" target="_blank" rel="external">安卓App热补丁动态修复技术介绍 </a></p>
<blockquote>
<p>概括来讲:如果引用者和被引用者的类(直接引用关系)在同一个Dex时,那么在虚拟机启动时,被引用类就会被打上CLASS_ISPREVERIFIED标志,这样被引用的类就不能进行热修复操作了. </p>
<p>那么我们就要阻止被引用类打上CLASS_ISPREVERIFIED标志.QQ空间的方法是在所有引用到该类的构造函数中插入一段代码,代码引用到别的类.</p>
</blockquote>
<h3 id="三、热修复的例子"><a href="#三、热修复的例子" class="headerlink" title="三、热修复的例子"></a>三、热修复的例子</h3><p>我用的是<a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">阿里开源的热修复框架AndFix热修复框架地址</a></p>
<p>其实它的原理也是动态加载<code>class</code>文件,然后调用反射完成修复.可参考我上一篇写的<br><a href="http://blog.csdn.net/qq_31530015/article/details/51768937" target="_blank" rel="external">Java的ClassLoader加载机制</a></p>
<p><code>AndFix</code>是<code>“Android Hot-Fix”</code>的缩写。它支持Android 2.3到6.0版本，并且支持arm与X86系统架构的设备。完美支持Dalvik与ART的Runtime。AndFix 的补丁文件是以<code>.apatch</code>结尾的文件。</p>
<p>我这是用<code>eclipse</code>写的<code>Demo</code>.</p>
<ol>
<li>把AndFix抽取成library依赖的形式</li>
</ol>
<p>这里写图片描述<br><img src="http://img.blog.csdn.net/20160702112015730" alt=""></p>
<ol>
<li>新建一个AndFixDemo项目,依赖AndFix这个library</li>
</ol>
<p>2.1</p>
<p>新建一个MyApplication继承Application<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyApplication"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * apatch文件</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APATCH_PATH = <span class="string">"/Dennis.apatch"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> PatchManager mPatchManager;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        <span class="comment">// 初始化</span></div><div class="line">        mPatchManager = <span class="keyword">new</span> PatchManager(<span class="keyword">this</span>);</div><div class="line">        mPatchManager.init(<span class="string">"1.0"</span>); <span class="comment">// 版本号</span></div><div class="line"></div><div class="line">        <span class="comment">// 加载 apatch</span></div><div class="line">        mPatchManager.loadPatch();</div><div class="line"></div><div class="line">        <span class="comment">//apatch文件的目录</span></div><div class="line">        String patchFileString = Environment.getExternalStorageDirectory().getAbsolutePath() + APATCH_PATH;</div><div class="line">        File apatchPath = <span class="keyword">new</span> File(patchFileString);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (apatchPath.exists()) &#123;</div><div class="line">            Log.i(TAG, <span class="string">"补丁文件存在"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//添加apatch文件</span></div><div class="line">                mPatchManager.addPatch(patchFileString);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                Log.i(TAG, <span class="string">"打补丁出错了"</span>);</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Log.i(TAG, <span class="string">"补丁文件不存在"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际当中肯定是通过网络接口下载<code>apatch</code>文件,我这里为了方便演示就放在了<code>SD</code>卡根目录</p>
<p>2.2</p>
<p>在<code>MainActivity</code>用一个按钮弹出吐司,上面是有<code>Bug</code>的代码,下面是修正后的代码</p>
<p>这里写图片描述<br><img src="http://img.blog.csdn.net/20160702113157906" alt=""></p>
<p>这里写图片描述<br><img src="http://img.blog.csdn.net/20160702113213904" alt=""><br>分别打包成Bug.apk和NoBug.apk</p>
<p>这里写图片描述<br><img src="http://img.blog.csdn.net/20160702113810924" alt=""></p>
<p>2.3</p>
<p>然后要用到一个<a href="https://github.com/alibaba/AndFix/raw/master/tools/apkpatch-1.0.3.zip" target="_blank" rel="external">生成补丁的工具apkpatch</a></p>
<p>解压</p>
<p>这里写图片描述<br><img src="http://img.blog.csdn.net/20160702114443271" alt=""></p>
<p>_MACOSX是给OSX系统用的<br>.bat是给window系统用的</p>
<p>我用得是<code>.bat</code></p>
<p>把之前生成的<code>Bug.apk</code>和<code>NoBug.apk</code>，还有打包所使用的<code>keystore</code>文件放到<code>apkpatch-1.0.3</code>目录下<br>打开<code>cmd</code>,进入到<code>apkpatch-1.0.3</code>目录下,输入如下指令</p>
<p><code>apkpatch.bat -f NoBug.apk -t Bug.apk -o Dennis -k keystore -p 111111 -a 111111 -e 111111</code></p>
<p>每个参数含义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-f 新版本的apk </div><div class="line">-t 旧版本的apk </div><div class="line">-o 输出apatch文件的文件夹,可以随意命名 </div><div class="line">-k 打包的keystore文件名 </div><div class="line">-p keystore的密码 </div><div class="line">-a keystore 用户别名 </div><div class="line">-e keystore 用户别名的密码</div></pre></td></tr></table></figure></p>
<p>这里写图片描述<br><img src="http://img.blog.csdn.net/20160702121447650" alt=""><br>如果出现add modified …….就表示成功了,去apkpatch-1.0.3目录看下,新增了Dennis目录</p>
<p>这里写图片描述<br><img src="http://img.blog.csdn.net/20160702125948475" alt=""><br>这里写图片描述<br><img src="http://img.blog.csdn.net/20160702130113648" alt=""><br>我把这个文件改为<code>Dennis.apatch</code></p>
<p>2.4</p>
<p>手机装上Bug.apk运行起来</p>
<p>这里写图片描述<br><img src="http://img.blog.csdn.net/20160702132032598" alt=""><br>然后把<code>Dennis.apatch</code> 放到<code>SD</code>卡根目录,退出<code>app</code>,再进入,按下按钮</p>
<p>这里写图片描述<br><img src="http://img.blog.csdn.net/20160702132048858" alt=""><br><a href="http://download.csdn.net/detail/qq_31530015/9565615" target="_blank" rel="external">最后附上Demo还有apk和apatch 文件 打开链接</a></p>
<p><img src="https://camo.githubusercontent.com/d27da621a6d7e8f612a3fe458b59a68ecb927bce/687474703a2f2f376676696f762e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f6e7577612e6a7067" alt=""></p>
<h2 id="Nuwa"><a href="#Nuwa" class="headerlink" title="Nuwa"></a><a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">Nuwa</a></h2><blockquote>
<p>Nuwa is a goddess in ancient Chinese mythology best known for repairing the pillar of heaven.With this Nuwa project，you can also have the repairing power, fix your android applicaiton without have to publish a new APK to the appstore.</p>
</blockquote>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/49883661" target="_blank" rel="external">Android 热补丁动态修复框架小结</a></p>
<p><a href="http://www.jianshu.com/p/ce6e157dae6d" target="_blank" rel="external">热修复初探</a></p>

            </div>
          

    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2015 -
    
    2017
    <span class="footer-author">MinusWang. All Rights Reserved. 砥砺前行-功不唐捐.</span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
